## Module 1-3

### Завдання №1

*Створіть абстрактний клас `Shape`, який буде представляти геометричну фігуру.
В цьому класі створіть абстрактний метод `area()`, який буде повертати площу фігури. 
Створіть два підкласи цього абстрактного класу: `Circle` і `Rectangle`. 
У кожному з цих підкласів реалізуйте метод `area()` для обчислення площі фігури.
Потім створіть екземпляри обох підкласів, обчисліть їх площу та виведіть результат.*


### Завдання №2

*Створи клас `Robot`, метод `__init__` якого приймає тільки name та записує його у властивість `self.name`, 
a властивість `self.partner` спочатку None.
Створи функцію `pair_robots`, яка приймає список з двох імен, створює для кожного екземпляр класу `Robot` та додає 
до кожного властивість `partner` з посиланням на партнера (інший об'єкт). Функція повертає кортеж з роботами.*

### Приклад використання

`robots = ['Alex','Tom']`

`new_robots = pair_robots(robots)`

`new_robots[0].name == 'Alex' # True` \
`all([isinstance(robot, Robot) for robot in new_robots]) # True` \
`new_robots[0].partner is new_robots[1] # True` \
`new_robots[1].partner is new_robots[0] # True`


### Завдання №3

*Створення системи для зоопарку для відстеження тварин.
Мета цього завдання - створити просту систему для зоопарку, 
яка дозволить відстежувати тварин за їхніми видами та іменами.*

*Створи базовий клас `Animal`, метод `init` якого приймає тільки name та записує його у властивість `self.name`.
Створи класи `Lion`, `Monkey`, і `Snake`, які наслідують від `Animal`. Кожен з цих класів повинен мати метод `make_sound`,
що повертає характерний звук для кожного виду тварин (наприклад, "Roar" для лева).
Створи функцію `create_animals`, яка створює екземпляри `Lion`, `Monkey`, і `Snake` з іменами, передає їх у список
і для кожної тварини виводить її ім'я та звук, який вона видає. Функція не повертає нічого, але виводить інформацію
про кожну тварину на екран.*


### Завдання №3.1 (продовження завдання №3)

*У цьому продовженні ми розробимо систему відстеження для зоопарку, 
яка дозволяє не тільки ідентифікувати тварин за їхніми видами та іменами, 
але й відслідковувати їх здоров'я, дієту та розклад активностей.*

  1.Додайте властивості `health` (здоров'я) та `diet` (дієта) до класу `Animal`.\
  2.Додайте методи для оновлення цих властивостей.\
  3.Створіть клас `ZooKeeper`, який буде відповідальний за догляд за тваринами.\
  4.Додайте метод `check_health` для перевірки здоров'я тварин. \
  5.Додайте метод `feed_animals` для годування тварин відповідно до їх дієти.\
  6.Створіть клас `ActivitySchedule` для кожної тварини.\
  7.Зберігайте інформацію про щоденні активності тварин (наприклад, час годування, 
  час для відпочинку, час для ігор).\
  8.Модифікуйте функцію `create_animals`, щоб вона також призначала кожній тварині `ZooKeeper`, 
  `ActivitySchedule` та ініціалізувала властивості `health` та `diet`.\
  9.Створіть декілька тварин, зоокіперів та розклади активностей.\
  10.Проведіть демонстрацію щоденних операцій у зоопарку: перевірка здоров'я, годування, відстеження активностей.\


### Завдання №4
*Створіть Dockerfile*

*Підказка:*
*Нам достатньо 4 команд*

### Завдання №5
*Створити симуляцію годівниці у лісі, де зайці, білки, і птахи (кожна тварина у своєму потоці) їдять 
з обмеженої кількості їжі. Синхронізувати доступ до годівниці, щоб уникнути конфліктів. 
Закінчити симуляцію, коли їжа закінчиться, і повідомити про нагодованих тварин.*

1. Створити клас `Feeder`, який буде відповідати за годівницю.
2. Створити клас `Animal`, який буде відповідати за тварину.
3. Створити класи `Rabbit`, `Bird`, `Squirrel`, які будуть наслідуватися від `Animal`.
4. В класі `Feeder` створити метод `eat`, який буде відповідати за годівницю.
5. В класі `Animal` створити метод `run`, який буде відповідати за тварину.
6. В класах `Rabbit`, `Bird`, `Squirrel` викликаємо конструктор батьківського класу.

### Приклад використання
    feeder = Feeder(20)

    animals = [Rabbit(feeder), Squirrel(feeder), Bird(feeder)]

    for animal in animals:
        animal.start() # start() - запускає потік

    for animal in animals:
        animal.join() # join() - чекає завершення потоку

    print("Всі тварини нагодовані.")

## Теорія

## Абстрактний клас

*Абстрактні класи - це своєрідні шаблони для інших класів. 
Вони дозволяють задати структуру або шаблон, якого повинні дотримуватися класи-нащадки. 
Ось основні моменти про абстрактні класи, викладені простими словами:*

1. Не для прямого використання:
Абстрактний клас - це не щось, що ви використовуєте безпосередньо. Ви не можете створити об'єкт абстрактного класу. Це більше як шаблон для інших класів.

2. Визначення правил:
Абстрактний клас вказує, які методи мають бути в класах, які його наслідують. Він може визначати абстрактні методи - це методи без реалізації, лише з описом того, що вони мають робити. Класи, які наслідують абстрактний клас, повинні надати конкретну реалізацію цих методів.

3. Створення узгодженої структури:
Це допомагає впорядкувати код, забезпечуючи, що всі класи-нащадки мають однакові методи. Це корисно у великих програмах, де багато різних частин повинні взаємодіяти одна з одною.

4. Гнучкість та розширюваність:
Абстрактні класи дозволяють легко розширювати програму. Ви можете визначити базову структуру в абстрактному класі, а потім наслідувати його і змінювати або доповнювати в класах-нащадках.

5. Простими словами, абстрактний клас - це як загальний план або набір правил, яких повинні дотримуватися всі, хто цей план використовує. Він вказує, що потрібно зробити, але не каже, як саме це зробити - це вирішують класи, які використовують цей план.

## Віртуальні середовища

*Віртуальні середовища в програмуванні - це ізольовані простори, 
де можна встановлювати і використовувати пакети та залежності без впливу 
на інші проекти або глобальну систему. Вони особливо корисні в Python, 
але концепція відома і в інших мовах програмування. 
Ось декілька популярних інструментів для створення віртуальних середовищ:*

1. `venv` (Virtual Environment):
Вбудований інструмент у Python 3, який дозволяє створювати віртуальні середовища. 
Кожне віртуальне середовище має свій ізольований набір бібліотек, 
що дозволяє різним проектам мати різні залежності. \
`python -m venv {myenv}`
2. `virtualenv`:
Ще один інструмент для створення віртуальних середовищ. 
`Virtualenv` працює з Python 2 та Python 3 і надає більше опцій, ніж `venv`. \
`pip install virtualenv`
`virtualenv {myenv}`
3. `conda` (Anaconda/Miniconda):
`Conda` - менеджер пакетів і віртуальних середовищ, що зазвичай використовується в 
наукових розрахунках і аналізі даних. 
Він дозволяє легко встановлювати, запускати і оновлювати пакети та їх залежності. \
`conda create -n {myenv} python=3.11`
4. `Pipenv`:
Інструмент, який спробує об'єднати `pip` і `virtualenv` в один інструмент. 
`Pipenv` автоматично створює і керує віртуальним середовищем для ваших проектів, 
а також додає/видаляє пакети з файлу `Pipfile`, коли ви встановлюєте/видаляєте пакети.
`pip install pipenv`
`pipenv install`
5. `Poetry`:
Інструмент для керування залежностями та упаковки в Python, 
який дозволяє оголошувати бібліотеки, які використовуються в проекті, і керувати ними. 
`Poetry` використовує власний формат для опису бібліотек і залежностей, 
що дозволяє вирішувати версії залежностей більш точно.
`pip install poetry`
`poetry install`

## Принципи SOLID

*Принципи SOLID — це п'ять основних правил для написання хорошого коду:*

1. Single Responsibility: Кожен клас чи функція повинні робити лише одну річ.
2. Open/Closed: Код має бути відкритим для розширення, але закритим для модифікації.
3. Liskov Substitution: Об'єкти класу можна замінити об'єктами його підкласів без порушення роботи програми.
4. Interface Segregation: Краще мати багато специфічних інтерфейсів, ніж один універсальний.
5. Dependency Inversion: Залежності всередині системи мають будуватися на основі абстракцій, а не конкретних деталей.

## Патерни проектування

*Патерни проектування в Python — це як шпаргалки для програмістів, 
що показують найкращі способи розв'язання типових завдань при написанні коду на Python.*

### Багатопоточність (потоки та процеси)

*Потік - це легкий підпроцес, що існує в межах процесу.
Використовуючи потоки, ми можемо виконувати кілька завдань одночасно в межах одного процесу.
Потік - це легкий підпроцес, що існує в межах процесу.
Використовуючи потоки, ми можемо виконувати кілька завдань одночасно в межах одного процесу.*


* В одному процесі може бути декілька потоків: 
Один процес може містити кілька потоків виконання, які ділять між собою пам'ять та ресурси цього процесу. 
Це називається багатопоточністю.

* В одному потоці не може бути декілька процесів: 
Кожен потік належить лише одному процесу. 
Процес може запускати інші процеси, але ці нові процеси будуть незалежними та матимуть свої власні потоки.